<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Jornada Laboral - IRISNOR</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ... (todos los estilos CSS se mantienen igual) ... */
    </style>
</head>
<body>
    <!-- ... (todo el HTML se mantiene igual) ... -->

    <!-- Main Application Script -->
    <script>
        // Configuración de Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyDPYnqZuduPYVPu8HxvqDG0PX-Gft8MOE0",
            authDomain: "fichaje-ded3c.firebaseapp.com",
            projectId: "fichaje-ded3c",
            storageBucket: "fichaje-ded3c.firebasestorage.app",
            messagingSenderId: "920545104442",
            appId: "1:920545104442:web:48195df317ad5ac1ff9b03",
            measurementId: "G-DQ97WCF7WX"
        };

        // Estado de la aplicación
        const state = {
            currentEmployee: null,
            employees: [],
            isAdmin: false,
            currentTime: new Date(),
            firebaseConnected: false,
            elapsedInterval: null,
            editingEmployeeId: null,
            activeEntry: null,
            realtimeListeners: {},
            displayedClockTime: null // Nuevo: almacena la hora del reloj visualizado
        };

        // Inicializar Firebase
        let app, db;
        
        // DOM Elements (se mantiene igual)
        // ...

        // Función para obtener la hora actual del reloj visualizado (NUEVA)
        function getDisplayedClockTime() {
            const timeString = elements.currentTime.textContent; // Formato: HH:MM:SS
            const [hours, minutes, seconds] = timeString.split(':').map(num => parseInt(num, 10));
            
            const now = new Date();
            now.setHours(hours, minutes, seconds, 0);
            return now;
        }

        // Función para formatear horas decimales a HH:MM:SS (CORREGIDA)
        function formatHours(decimalHours) {
            if (decimalHours === undefined || decimalHours === null || isNaN(decimalHours)) {
                return "00:00:00";
            }
            
            const hours = parseFloat(decimalHours);
            if (isNaN(hours)) {
                return "00:00:00";
            }
            
            const absoluteHours = Math.abs(hours);
            const totalSeconds = Math.round(absoluteHours * 3600);
            const hrs = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            return `${hrs.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Función para convertir fecha manual a objeto Date válido (ACTUALIZADA para usar el reloj visualizado)
        function parseManualDateTime(datetimeString) {
            if (!datetimeString) {
                // Si no hay fecha manual, usar la hora del reloj visualizado
                return getDisplayedClockTime();
            }
            
            try {
                // Si hay fecha manual, extraer solo la fecha
                const datePart = datetimeString.split('T')[0];
                
                // Obtener la hora del reloj visualizado
                const clockTime = getDisplayedClockTime();
                
                // Crear nueva fecha con fecha manual + hora del reloj
                const [year, month, day] = datePart.split('-').map(num => parseInt(num, 10));
                const newDate = new Date(year, month - 1, day, 
                    clockTime.getHours(), clockTime.getMinutes(), clockTime.getSeconds(), 0);
                
                return newDate;
            } catch (error) {
                console.error("Error parseando fecha manual:", error);
                return getDisplayedClockTime();
            }
        }

        // Función para convertir Timestamp de Firestore a Date
        function convertTimestampToDate(timestamp) {
            if (timestamp && timestamp.toDate) {
                return timestamp.toDate();
            }
            return new Date(timestamp);
        }

        // Función para mostrar modal de confirmación personalizado
        function showConfirmationModal(title, message, icon, type) {
            // ... (se mantiene igual)
        }

        // Obtener color por tipo de registro especial
        function getColorByType(type) {
            // ... (se mantiene igual)
        }

        // Función para formatear la hora con segundos (hh:mm:ss)
        function formatTimeWithSeconds(date) {
            if (!date) return '00:00:00';
            
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const seconds = date.getSeconds().toString().padStart(2, '0');
            
            return `${hours}:${minutes}:${seconds}`;
        }

        // Función para obtener la fecha actual en formato YYYY-MM-DD
        function getCurrentDateString() {
            const now = new Date();
            return now.toISOString().split('T')[0];
        }

        // Función para obtener la hora actual en formato HH:MM:SS
        function getCurrentTimeString() {
            const now = new Date();
            return formatTimeWithSeconds(now);
        }

        // Inicializar la aplicación
        async function initApp() {
            showLoading("Inicializando sistema...");
            
            try {
                // Verificar si Firebase está disponible
                if (typeof firebase === 'undefined') {
                    throw new Error("Firebase no se cargó correctamente");
                }
                
                // Inicializar Firebase
                app = firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                
                console.log("✅ Firebase inicializado");
                
                // Verificar conexión a Firestore
                await testFirestoreConnection();
                
                state.firebaseConnected = true;
                elements.firebaseStatus.textContent = "Conectado a Firebase";
                elements.firebaseStatus.style.color = "#27ae60";
                
                // Configurar fecha/hora manual con la fecha actual y hora del reloj
                updateManualDatetimeField();
                
                // Cargar empleado recordado
                loadRememberedEmployee();
                
                // Cargar empleados
                await loadEmployees();
                
                // Actualizar reloj
                updateClock();
                setInterval(updateClock, 1000);
                
                // Configurar event listeners
                setupEventListeners();
                
                hideLoading();
                showToast("Sistema inicializado correctamente", "success");
                
            } catch (error) {
                console.error("Error inicializando la aplicación:", error);
                elements.firebaseStatus.textContent = "Error de conexión";
                elements.firebaseStatus.style.color = "#e74c3c";
                hideLoading();
                showToast(`Error: ${error.message}. Usando modo local.`, "error");
                
                // Cargar datos de demostración
                loadDemoData();
            }
        }

        // Actualizar campo de fecha manual con fecha actual y hora del reloj (NUEVA)
        function updateManualDatetimeField() {
            const now = new Date();
            const year = now.getFullYear();
            const month = (now.getMonth() + 1).toString().padStart(2, '0');
            const day = now.getDate().toString().padStart(2, '0');
            
            // Obtener hora del reloj visualizado
            const clockTime = state.displayedClockTime || now;
            const hours = clockTime.getHours().toString().padStart(2, '0');
            const minutes = clockTime.getMinutes().toString().padStart(2, '0');
            const seconds = clockTime.getSeconds().toString().padStart(2, '0');
            
            elements.manualDatetime.value = `${year}-${month}-${day}T${hours}:${minutes}:${seconds}`;
        }

        // Probar conexión a Firestore
        async function testFirestoreConnection() {
            try {
                // Intentar leer una colección para probar conexión
                const testRef = db.collection('test_connection');
                const querySnapshot = await testRef.limit(1).get();
                console.log("✅ Conexión a Firestore exitosa");
                return true;
            } catch (error) {
                console.error("❌ Error de conexión a Firestore:", error);
                return true;
            }
        }

        // Configurar event listeners
        function setupEventListeners() {
            // Tabs
            elements.tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.getAttribute('data-tab');
                    switchTab(tabId);
                });
            });

            // Selección de empleado
            elements.employeeSelect.addEventListener('change', function() {
                const employeeId = this.value;
                if (employeeId) {
                    const employee = state.employees.find(emp => emp.id === employeeId);
                    if (employee) {
                        state.currentEmployee = employee;
                        
                        // Detener listener anterior si existe
                        if (state.realtimeListeners[employeeId]) {
                            state.realtimeListeners[employeeId]();
                            delete state.realtimeListeners[employeeId];
                        }
                        
                        // Iniciar listener en tiempo real para este empleado
                        setupEmployeeRealtimeListener(employeeId);
                        
                        updateEmployeeUI();
                        loadEmployeeStatistics(employeeId);
                        
                        // Recordar empleado
                        if (elements.rememberEmployee.checked) {
                            localStorage.setItem('rememberedEmployee', employeeId);
                        }
                    }
                } else {
                    state.currentEmployee = null;
                    updateEmployeeUI();
                }
            });

            // Checkbox recordar empleado
            elements.rememberEmployee.addEventListener('change', function() {
                if (!this.checked) {
                    localStorage.removeItem('rememberedEmployee');
                }
            });

            // Botones de actualización
            elements.refreshEmployeesBtn.addEventListener('click', async () => {
                await loadEmployees();
                showToast("Lista de empleados actualizada", "success");
            });

            elements.refreshStatusBtn.addEventListener('click', async () => {
                if (state.currentEmployee) {
                    await loadEmployeeActiveStatus(state.currentEmployee.id);
                    showToast("Estado actualizado", "info");
                } else {
                    showToast("Seleccione un operario primero", "warning");
                }
            });

            // Botones especiales (con confirmación)
            elements.vacationBtn.addEventListener('click', function() {
                registerSpecialDay('vacation');
            });

            elements.sickBtn.addEventListener('click', function() {
                registerSpecialDay('sick');
            });

            elements.travelBtn.addEventListener('click', function() {
                registerSpecialDay('travel');
            });

            // Botones de entrada/salida
            elements.entryBtn.addEventListener('click', () => registerTime('entry'));
            elements.exitBtn.addEventListener('click', () => registerTime('exit'));

            // Login admin
            elements.loginBtn.addEventListener('click', adminLogin);

            // Logout admin
            elements.logoutBtn.addEventListener('click', adminLogout);

            // Gestión de empleados
            elements.addEmployeeBtn.addEventListener('click', () => {
                openEmployeeModal();
            });

            // Cerrar modales
            elements.closeModalButtons.forEach(button => {
                button.addEventListener('click', () => {
                    closeEmployeeModal();
                });
            });

            // Guardar empleado
            elements.saveEmployeeBtn.addEventListener('click', async () => {
                await saveEmployee();
            });

            // Eliminar empleado
            elements.deleteEmployeeBtn.addEventListener('click', async () => {
                await deleteEmployee();
            });

            // Asignar vacaciones
            elements.assignVacationBtn.addEventListener('click', async () => {
                await assignVacation();
            });

            // Filtrar registros
            elements.filterBtn.addEventListener('click', async () => {
                await filterRecords();
            });

            // Exportar registros
            elements.exportBtn.addEventListener('click', exportRecords);

            // Clic fuera del modal para cerrar
            window.addEventListener('click', (event) => {
                if (event.target === elements.employeeModal) {
                    closeEmployeeModal();
                }
            });

            // Atajos de teclado
            document.addEventListener('keydown', (e) => {
                if (elements.operatorTab.classList.contains('active') && state.currentEmployee) {
                    if (e.key === 'e' || e.key === 'E') {
                        e.preventDefault();
                        elements.entryBtn.click();
                    } else if (e.key === 's' || e.key === 'S') {
                        e.preventDefault();
                        elements.exitBtn.click();
                    } else if (e.key === 'v' || e.key === 'V') {
                        e.preventDefault();
                        elements.vacationBtn.click();
                    }
                }
            });

            // Actualizar fecha/hora manual cuando cambia el reloj
            setInterval(() => {
                if (!document.activeElement || document.activeElement.id !== 'manual-datetime') {
                    updateManualDatetimeField();
                }
            }, 1000);
        }

        // Configurar listener en tiempo real para empleado
        function setupEmployeeRealtimeListener(employeeId) {
            // ... (se mantiene igual)
        }

        // Cambiar pestaña
        function switchTab(tabId) {
            // ... (se mantiene igual)
        }

        // Cargar empleado recordado
        function loadRememberedEmployee() {
            // ... (se mantiene igual)
        }

        // Cargar empleados desde Firebase
        async function loadEmployees() {
            // ... (se mantiene igual)
        }

        // Actualizar lista de empleados en admin
        function updateEmployeesList() {
            // ... (se mantiene igual)
        }

        // Abrir modal de empleado
        function openEmployeeModal(employeeId = null) {
            // ... (se mantiene igual)
        }

        // Cerrar modal de empleado
        function closeEmployeeModal() {
            // ... (se mantiene igual)
        }

        // Guardar empleado
        async function saveEmployee() {
            // ... (se mantiene igual)
        }

        // Eliminar empleado
        async function deleteEmployee(employeeId = null) {
            // ... (se mantiene igual)
        }

        // Actualizar reloj - MODIFICADA para guardar la hora visualizada
        function updateClock() {
            state.currentTime = new Date();
            const timeString = formatTimeWithSeconds(state.currentTime);
            elements.currentTime.textContent = timeString;
            
            // Guardar la hora visualizada para usar en registros
            state.displayedClockTime = state.currentTime;
            
            // Actualizar tiempo transcurrido si hay una entrada activa
            if (state.activeEntry) {
                updateElapsedTime();
            }
        }

        // Actualizar tiempo transcurrido
        function updateElapsedTime() {
            if (!state.activeEntry || !state.activeEntry.entryTime) return;
            
            const entryTime = new Date(state.activeEntry.entryTime);
            const now = getDisplayedClockTime(); // Usar hora del reloj visualizado
            
            const diffMs = now - entryTime;
            
            // Calcular horas, minutos, segundos
            const hours = Math.floor(diffMs / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((diffMs % (1000 * 60)) / 1000);
            
            // Formatear con ceros a la izquierda
            const format = (num) => num.toString().padStart(2, '0');
            
            elements.elapsedHours.textContent = format(hours);
            elements.elapsedMinutes.textContent = format(minutes);
            elements.elapsedSeconds.textContent = format(seconds);
            
            // Mostrar contador
            elements.elapsedTime.style.display = 'block';
        }

        // Cargar estado activo del empleado desde Firebase
        async function loadEmployeeActiveStatus(employeeId) {
            // ... (se mantiene igual)
        }

        // Actualizar UI del empleado
        function updateEmployeeUI() {
            // ... (se mantiene igual)
        }

        // Registrar día especial (vacaciones, baja, viaje) con confirmación
        async function registerSpecialDay(type) {
            if (!state.currentEmployee) {
                showToast("Seleccione un operario primero", "warning");
                return;
            }
            
            // Siempre usar la hora del reloj visualizado (ignorando el campo manual para la hora)
            let recordTime = parseManualDateTime(elements.manualDatetime.value);
            
            // Definir mensajes de confirmación específicos para cada tipo
            const confirmMessages = {
                'vacation': {
                    title: 'Registrar Vacaciones',
                    message: `¿Está seguro de registrar VACACIONES para ${state.currentEmployee.name}?\n\nSe descontará 1 día de sus vacaciones disponibles.`,
                    icon: 'fas fa-umbrella-beach'
                },
                'sick': {
                    title: 'Registrar Baja Laboral',
                    message: `¿Está seguro de registrar BAJA LABORAL para ${state.currentEmployee.name}?`,
                    icon: 'fas fa-hospital'
                },
                'travel': {
                    title: 'Registrar Viaje de Trabajo',
                    message: `¿Está seguro de registrar VIAJE DE TRABAJO para ${state.currentEmployee.name}?\n\n• Se registrarán 8 horas automáticamente\n• Si es fin de semana, se añadirá 1 día extra de vacaciones`,
                    icon: 'fas fa-plane'
                }
            };
            
            const confirmData = confirmMessages[type];
            
            // Crear modal de confirmación personalizado
            const confirmed = await showConfirmationModal(
                confirmData.title,
                confirmData.message,
                confirmData.icon,
                type
            );
            
            if (!confirmed) {
                showToast("Registro cancelado", "info");
                return;
            }
            
            // Para viajes, verificar si es fin de semana
            let extraVacation = 0;
            if (type === 'travel') {
                const dayOfWeek = recordTime.getDay();
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    extraVacation = 1;
                }
            }
            
            // Crear registro usando la hora del reloj visualizado
            const record = {
                employeeId: state.currentEmployee.id,
                employeeName: state.currentEmployee.name,
                type: type,
                timestamp: recordTime,
                date: recordTime.toISOString().split('T')[0],
                year: recordTime.getFullYear(),
                month: recordTime.getMonth() + 1,
                day: recordTime.getDate(),
                hour: recordTime.getHours(),
                minute: recordTime.getMinutes(),
                second: recordTime.getSeconds(),
                extraVacation: extraVacation,
                hoursWorkedFormatted: type === 'travel' ? '08:00:00' : null,
                timeFormatted: formatTimeWithSeconds(recordTime)
            };
            
            // Para viaje, asignar automáticamente 8 horas
            if (type === 'travel') {
                record.hoursWorked = 8;
            }
            
            try {
                // Guardar en Firebase
                await db.collection('records').add(record);
                
                // Si es viaje y hay vacaciones extra, actualizar empleado
                if (type === 'travel' && extraVacation > 0) {
                    const newVacationDays = (state.currentEmployee.vacationDays2026 || 0) + extraVacation;
                    await db.collection('employees').doc(state.currentEmployee.id).update({
                        vacationDays2026: newVacationDays
                    });
                    state.currentEmployee.vacationDays2026 = newVacationDays;
                    showToast(`Viaje en fin de semana. Se añadió ${extraVacation} día extra de vacaciones.`, "info");
                }
                
                // Si es vacaciones, restar día
                if (type === 'vacation' && state.currentEmployee.vacationDays2026 > 0) {
                    const newVacationDays = state.currentEmployee.vacationDays2026 - 1;
                    await db.collection('employees').doc(state.currentEmployee.id).update({
                        vacationDays2026: newVacationDays
                    });
                    state.currentEmployee.vacationDays2026 = newVacationDays;
                }
                
                // Actualizar UI
                updateEmployeeUI();
                
                // Recargar estadísticas
                await loadEmployeeStatistics(state.currentEmployee.id);
                
                // Mostrar mensaje de éxito
                const typeNames = {
                    'vacation': 'Vacaciones',
                    'sick': 'Baja laboral',
                    'travel': 'Viaje de trabajo'
                };
                
                showToast(`${typeNames[type]} registrada correctamente a las ${formatTimeWithSeconds(recordTime)}`, "success");
                
                // Actualizar campo manual con la hora actual
                updateManualDatetimeField();
                
            } catch (error) {
                console.error("Error registrando día especial:", error);
                showToast(`Error: ${error.message}`, "error");
            }
        }

        // Registrar tiempo (entrada/salida) - MODIFICADA para usar hora del reloj visualizado
        async function registerTime(type) {
            if (!state.currentEmployee) {
                showToast("Seleccione un operario primero", "warning");
                return;
            }
            
            // Siempre usar la hora del reloj visualizado
            let recordTime = parseManualDateTime(elements.manualDatetime.value);
            
            try {
                if (type === 'entry') {
                    // Verificar si ya hay una entrada activa
                    if (state.activeEntry) {
                        showToast("Ya hay una entrada registrada. Registre salida primero.", "warning");
                        return;
                    }
                    
                    // Registrar entrada usando la hora del reloj visualizado
                    const record = {
                        employeeId: state.currentEmployee.id,
                        employeeName: state.currentEmployee.name,
                        type: 'entry',
                        timestamp: recordTime,
                        date: recordTime.toISOString().split('T')[0],
                        year: recordTime.getFullYear(),
                        month: recordTime.getMonth() + 1,
                        day: recordTime.getDate(),
                        hour: recordTime.getHours(),
                        minute: recordTime.getMinutes(),
                        second: recordTime.getSeconds(),
                        timeFormatted: formatTimeWithSeconds(recordTime)
                    };
                    
                    // Guardar registro de entrada
                    const recordRef = await db.collection('records').add(record);
                    
                    // Actualizar estado activo en el empleado
                    const activeEntry = {
                        entryTime: recordTime,
                        entryRecordId: recordRef.id,
                        lastAction: 'entry',
                        lastActionTime: recordTime
                    };
                    
                    await db.collection('employees').doc(state.currentEmployee.id).update({
                        activeEntry: activeEntry,
                        lastAction: 'entry',
                        lastActionTime: recordTime
                    });
                    
                    // Actualizar estado local
                    state.activeEntry = activeEntry;
                    state.currentEmployee.activeEntry = activeEntry;
                    
                    showToast(`Entrada registrada a las ${formatTimeWithSeconds(recordTime)}`, "success");
                    
                } else if (type === 'exit') {
                    // Registrar salida usando la hora del reloj visualizado
                    if (!state.activeEntry) {
                        showToast("No hay entrada activa para registrar salida", "warning");
                        return;
                    }
                    
                    const record = {
                        employeeId: state.currentEmployee.id,
                        employeeName: state.currentEmployee.name,
                        type: 'exit',
                        timestamp: recordTime,
                        date: recordTime.toISOString().split('T')[0],
                        year: recordTime.getFullYear(),
                        month: recordTime.getMonth() + 1,
                        day: recordTime.getDate(),
                        hour: recordTime.getHours(),
                        minute: recordTime.getMinutes(),
                        second: recordTime.getSeconds(),
                        timeFormatted: formatTimeWithSeconds(recordTime)
                    };
                    
                    // Calcular horas trabajadas usando la hora del reloj visualizado
                    const entryTime = new Date(state.activeEntry.entryTime);
                    const hoursWorked = (recordTime - entryTime) / (1000 * 60 * 60);
                    record.hoursWorked = hoursWorked;
                    record.hoursWorkedFormatted = formatHours(hoursWorked);
                    
                    // Guardar registro de salida
                    await db.collection('records').add(record);
                    
                    // Limpiar estado activo en el empleado
                    await db.collection('employees').doc(state.currentEmployee.id).update({
                        activeEntry: null,
                        lastAction: 'exit',
                        lastActionTime: recordTime
                    });
                    
                    // Actualizar estado local
                    state.activeEntry = null;
                    state.currentEmployee.activeEntry = null;
                    
                    showToast(`Salida registrada a las ${formatTimeWithSeconds(recordTime)}. Horas trabajadas: ${formatHours(hoursWorked)}`, "success");
                }
                
                // Actualizar UI
                updateEmployeeUI();
                
                // Recargar estadísticas
                await loadEmployeeStatistics(state.currentEmployee.id);
                
                // Actualizar campo manual con la hora actual
                updateManualDatetimeField();
                
            } catch (error) {
                console.error("Error registrando tiempo:", error);
                showToast(`Error: ${error.message}`, "error");
            }
        }

        // Cargar estadísticas del empleado (ACTUALIZADA para usar hora del reloj en cálculos)
        async function loadEmployeeStatistics(employeeId) {
            try {
                const today = new Date();
                const todayString = today.toISOString().split('T')[0];
                const currentMonth = today.getMonth() + 1;
                const currentYear = today.getFullYear();
                
                // Obtener registros del empleado para el mes actual
                const snapshot = await db.collection('records')
                    .where('employeeId', '==', employeeId)
                    .where('year', '==', currentYear)
                    .where('month', '==', currentMonth)
                    .get();
                
                let totalHoursToday = 0;
                let totalHoursMonth = 0;
                let daysWorkedSet = new Set();
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const record = {
                        ...data,
                        timestamp: convertTimestampToDate(data.timestamp)
                    };
                    
                    // Calcular horas para hoy
                    if (record.date === todayString) {
                        if (record.type === 'exit' && record.hoursWorked) {
                            totalHoursToday += parseFloat(record.hoursWorked) || 0;
                        } else if (record.type === 'travel' && record.hoursWorked) {
                            totalHoursToday += parseFloat(record.hoursWorked) || 0;
                        }
                    }
                    
                    // Calcular horas para el mes
                    if (record.type === 'exit' && record.hoursWorked) {
                        totalHoursMonth += parseFloat(record.hoursWorked) || 0;
                    } else if (record.type === 'travel' && record.hoursWorked) {
                        totalHoursMonth += parseFloat(record.hoursWorked) || 0;
                    }
                    
                    // Días trabajados (solo entradas y salidas normales)
                    if (record.type === 'entry' || record.type === 'exit') {
                        daysWorkedSet.add(record.date);
                    }
                });
                
                // Actualizar estadísticas
                const daysWorkedCount = daysWorkedSet.size;
                elements.hoursToday.textContent = formatHours(totalHoursToday);
                elements.hoursMonth.textContent = formatHours(totalHoursMonth);
                elements.daysWorked.textContent = daysWorkedCount.toString();
                
            } catch (error) {
                console.error("Error cargando estadísticas:", error);
                elements.hoursToday.textContent = "00:00:00";
                elements.hoursMonth.textContent = "00:00:00";
                elements.daysWorked.textContent = "0";
            }
        }

        // Login administrador
        function adminLogin() {
            // ... (se mantiene igual)
        }

        // Logout administrador
        function adminLogout() {
            // ... (se mantiene igual)
        }

        // Cargar estadísticas globales para admin (ACTUALIZADA)
        async function loadAdminStatistics() {
            try {
                const today = new Date();
                const todayString = today.toISOString().split('T')[0];
                const currentMonth = today.getMonth() + 1;
                const currentYear = today.getFullYear();
                
                // Obtener todos los registros del mes actual
                const snapshot = await db.collection('records')
                    .where('year', '==', currentYear)
                    .where('month', '==', currentMonth)
                    .get();
                
                let totalHoursToday = 0;
                let totalHoursMonth = 0;
                let usedVacationDays = 0;
                let travelDays = 0;
                let travelHours = 0;
                let sickDays = 0;
                let daysWorkedSet = new Set();
                
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const record = {
                        ...data,
                        timestamp: convertTimestampToDate(data.timestamp)
                    };
                    
                    // Calcular horas para hoy
                    if (record.date === todayString) {
                        if (record.type === 'exit' && record.hoursWorked) {
                            totalHoursToday += parseFloat(record.hoursWorked) || 0;
                        } else if (record.type === 'travel' && record.hoursWorked) {
                            totalHoursToday += parseFloat(record.hoursWorked) || 0;
                        }
                    }
                    
                    // Calcular horas para el mes
                    if (record.type === 'exit' && record.hoursWorked) {
                        totalHoursMonth += parseFloat(record.hoursWorked) || 0;
                    } else if (record.type === 'travel' && record.hoursWorked) {
                        totalHoursMonth += parseFloat(record.hoursWorked) || 0;
                        travelHours += parseFloat(record.hoursWorked) || 0;
                    }
                    
                    // Contar días especiales
                    if (record.type === 'vacation') {
                        usedVacationDays++;
                    } else if (record.type === 'travel') {
                        travelDays++;
                    } else if (record.type === 'sick') {
                        sickDays++;
                    }
                    
                    // Días trabajados (solo entradas y salidas normales)
                    if (record.type === 'entry' || record.type === 'exit') {
                        daysWorkedSet.add(record.date + '_' + record.employeeId);
                    }
                });
                
                // Actualizar estadísticas
                elements.totalHoursToday.textContent = formatHours(totalHoursToday);
                elements.totalHoursMonth.textContent = formatHours(totalHoursMonth);
                elements.usedVacation.textContent = `${usedVacationDays}d`;
                elements.travelDays.textContent = travelDays.toString();
                elements.travelHours.textContent = formatHours(travelHours);
                elements.sickDays.textContent = sickDays.toString();
                elements.totalDaysWorked.textContent = daysWorkedSet.size.toString();
                
            } catch (error) {
                console.error("Error cargando estadísticas admin:", error);
                elements.totalHoursToday.textContent = "00:00:00";
                elements.totalHoursMonth.textContent = "00:00:00";
                elements.usedVacation.textContent = "0d";
                elements.travelDays.textContent = "0";
                elements.travelHours.textContent = "00:00:00";
                elements.sickDays.textContent = "0";
                elements.totalDaysWorked.textContent = "0";
            }
        }

        // Asignar vacaciones
        async function assignVacation() {
            // ... (se mantiene igual)
        }

        // Filtrar registros
        async function filterRecords() {
            // ... (se mantiene igual)
        }

        // Actualizar visualización de registros en admin
        function updateAdminRecordsDisplay(records) {
            // ... (se mantiene igual)
        }

        // Exportar registros
        function exportRecords() {
            // ... (se mantiene igual)
        }

        // Mostrar toast
        function showToast(message, type = "success") {
            // ... (se mantiene igual)
        }

        // Mostrar loading
        function showLoading(message = "Cargando...") {
            // ... (se mantiene igual)
        }

        // Ocultar loading
        function hideLoading() {
            // ... (se mantiene igual)
        }

        // Cargar datos de demostración
        function loadDemoData() {
            // ... (se mantiene igual)
        }

        // Actualizar selects de empleados
        function updateEmployeeSelects() {
            // ... (se mantiene igual)
        }

        // Inicializar cuando cargue la página
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>