<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Jornada Laboral - IRISNOR</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ... (todo el CSS se mantiene igual) ... */
    </style>
</head>
<body>
    <!-- ... (todo el HTML se mantiene igual hasta el script) ... -->

    <!-- Main Application Script -->
    <script>
        // Configuración de Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyDPYnqZuduPYVPu8HxvqDG0PX-Gft8MOE0",
            authDomain: "fichaje-ded3c.firebaseapp.com",
            projectId: "fichaje-ded3c",
            storageBucket: "fichaje-ded3c.firebasestorage.app",
            messagingSenderId: "920545104442",
            appId: "1:920545104442:web:48195df317ad5ac1ff9b03",
            measurementId: "G-DQ97WCF7WX"
        };

        // Estado de la aplicación
        const state = {
            currentEmployee: null,
            employees: [],
            isAdmin: false,
            currentTime: new Date(),
            firebaseConnected: false,
            elapsedInterval: null,
            editingEmployeeId: null,
            activeEntry: null
        };

        // Inicializar Firebase
        let app, db;
        
        // DOM Elements (se mantienen igual hasta donde sea necesario modificar)
        const elements = {
            // ... (todos los elementos se mantienen igual) ...
        };

        // Función para formatear horas decimales a HH:MM:SS
        function formatHours(decimalHours) {
            const totalSeconds = Math.round(decimalHours * 3600);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Función para formatear fecha a formato compatible
        function formatDateTimeForInput(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        // Función para parsear fecha manual correctamente
        function parseManualDateTime(manualValue) {
            if (!manualValue) return new Date();
            
            // Asegurar que la fecha tenga el formato correcto
            const date = new Date(manualValue);
            
            // Verificar si la fecha es válida
            if (isNaN(date.getTime())) {
                // Intentar con formato alternativo
                const parts = manualValue.split('T');
                if (parts.length === 2) {
                    const [datePart, timePart] = parts;
                    const [year, month, day] = datePart.split('-').map(Number);
                    const [hours, minutes] = timePart.split(':').map(Number);
                    return new Date(year, month - 1, day, hours, minutes, 0);
                }
                return new Date(); // Fallback a fecha actual
            }
            return date;
        }

        // Inicializar la aplicación
        async function initApp() {
            showLoading("Inicializando sistema...");
            
            try {
                // Verificar si Firebase está disponible
                if (typeof firebase === 'undefined') {
                    throw new Error("Firebase no se cargó correctamente");
                }
                
                // Inicializar Firebase
                app = firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                
                console.log("✅ Firebase inicializado");
                
                // Verificar conexión a Firestore
                await testFirestoreConnection();
                
                state.firebaseConnected = true;
                elements.firebaseStatus.textContent = "Conectado a Firebase";
                elements.firebaseStatus.style.color = "#27ae60";
                
                // Configurar fecha/hora manual con formato correcto
                elements.manualDatetime.value = formatDateTimeForInput(new Date());
                
                // Cargar empleado recordado
                loadRememberedEmployee();
                
                // Cargar empleados
                await loadEmployees();
                
                // Actualizar reloj
                updateClock();
                setInterval(updateClock, 1000);
                
                // Configurar event listeners
                setupEventListeners();
                
                hideLoading();
                showToast("Sistema inicializado correctamente", "success");
                
            } catch (error) {
                console.error("Error inicializando la aplicación:", error);
                elements.firebaseStatus.textContent = "Error de conexión";
                elements.firebaseStatus.style.color = "#e74c3c";
                hideLoading();
                showToast(`Error: ${error.message}. Usando modo local.`, "error");
                
                // Cargar datos de demostración
                loadDemoData();
            }
        }

        // Probar conexión a Firestore
        async function testFirestoreConnection() {
            try {
                // Intentar leer una colección para probar conexión
                const testRef = db.collection('test_connection');
                const docRef = await testRef.add({
                    test: true,
                    timestamp: new Date(),
                    message: "Prueba de conexión"
                });
                
                console.log("✅ Conexión a Firestore exitosa, documento ID:", docRef.id);
                return true;
                
            } catch (error) {
                console.error("❌ Error de conexión a Firestore:", error);
                
                // Mostrar instrucciones para solucionar
                if (error.code === 'permission-denied') {
                    showToast("Error de permisos. Verifica las reglas de Firestore.", "error");
                } else if (error.message.includes('not-found') || error.code === 'not-found') {
                    showToast("Firestore no está habilitado. Habilítalo en Firebase Console.", "error");
                }
                
                throw error;
            }
        }

        // Configurar event listeners
        function setupEventListeners() {
            // ... (todos los event listeners se mantienen igual hasta donde sea necesario modificar) ...

            // Botones especiales
            elements.vacationBtn.addEventListener('click', function() {
                registerSpecialDay('vacation');
            });

            elements.sickBtn.addEventListener('click', function() {
                registerSpecialDay('sick');
            });

            elements.travelBtn.addEventListener('click', function() {
                registerSpecialDay('travel');
            });

            // Botones de entrada/salida
            elements.entryBtn.addEventListener('click', () => registerTime('entry'));
            elements.exitBtn.addEventListener('click', () => registerTime('exit'));
            
            // ... (resto de event listeners se mantienen igual) ...
        }

        // Registrar día especial (vacaciones, baja, viaje)
        async function registerSpecialDay(type) {
            if (!state.currentEmployee) {
                showToast("Seleccione un operario primero", "warning");
                return;
            }
            
            // Usar hora manual o actual
            const useManualTime = elements.manualDatetime.value !== '';
            let recordTime;
            
            if (useManualTime) {
                recordTime = parseManualDateTime(elements.manualDatetime.value);
            } else {
                recordTime = new Date();
            }
            
            // Para viajes, verificar si es fin de semana
            let extraVacation = 0;
            if (type === 'travel') {
                const dayOfWeek = recordTime.getDay(); // 0 = Domingo, 6 = Sábado
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    extraVacation = 1;
                }
            }
            
            // Crear registro
            const record = {
                employeeId: state.currentEmployee.id,
                employeeName: state.currentEmployee.name,
                type: type,
                timestamp: recordTime,
                date: recordTime.toISOString().split('T')[0],
                year: recordTime.getFullYear(),
                month: recordTime.getMonth() + 1,
                day: recordTime.getDate(),
                hour: recordTime.getHours(),
                minute: recordTime.getMinutes(),
                extraVacation: extraVacation,
                dateString: recordTime.toLocaleDateString('es-ES')
            };
            
            // Para viaje, asignar automáticamente 8 horas
            if (type === 'travel') {
                record.hoursWorked = 8;
            }
            
            try {
                // Guardar en Firebase
                await db.collection('records').add(record);
                
                // Si es viaje y hay vacaciones extra, actualizar empleado
                if (type === 'travel' && extraVacation > 0) {
                    const newVacationDays = (state.currentEmployee.vacationDays2026 || 0) + extraVacation;
                    await db.collection('employees').doc(state.currentEmployee.id).update({
                        vacationDays2026: newVacationDays
                    });
                    state.currentEmployee.vacationDays2026 = newVacationDays;
                    showToast(`Viaje en fin de semana. Se añadió ${extraVacation} día extra de vacaciones.`, "info");
                }
                
                // Si es vacaciones, restar día
                if (type === 'vacation' && state.currentEmployee.vacationDays2026 > 0) {
                    const newVacationDays = state.currentEmployee.vacationDays2026 - 1;
                    await db.collection('employees').doc(state.currentEmployee.id).update({
                        vacationDays2026: newVacationDays
                    });
                    state.currentEmployee.vacationDays2026 = newVacationDays;
                }
                
                // Actualizar UI
                updateEmployeeUI();
                
                // Recargar estadísticas
                await loadEmployeeStatistics(state.currentEmployee.id);
                
                // Mostrar mensaje de éxito
                const typeNames = {
                    'vacation': 'Vacaciones',
                    'sick': 'Baja laboral',
                    'travel': 'Viaje'
                };
                
                showToast(`${typeNames[type]} registrada correctamente`, "success");
                
                // Resetear fecha manual
                if (useManualTime) {
                    elements.manualDatetime.value = formatDateTimeForInput(new Date());
                }
                
            } catch (error) {
                console.error("Error registrando día especial:", error);
                showToast(`Error: ${error.message}`, "error");
            }
        }

        // Registrar tiempo (entrada/salida)
        async function registerTime(type) {
            if (!state.currentEmployee) {
                showToast("Seleccione un operario primero", "warning");
                return;
            }
            
            // Usar hora manual o actual
            const useManualTime = elements.manualDatetime.value !== '';
            let recordTime;
            
            if (useManualTime) {
                recordTime = parseManualDateTime(elements.manualDatetime.value);
            } else {
                recordTime = new Date();
            }
            
            // Crear registro
            const record = {
                employeeId: state.currentEmployee.id,
                employeeName: state.currentEmployee.name,
                type: type,
                timestamp: recordTime,
                date: recordTime.toISOString().split('T')[0],
                year: recordTime.getFullYear(),
                month: recordTime.getMonth() + 1,
                day: recordTime.getDate(),
                hour: recordTime.getHours(),
                minute: recordTime.getMinutes(),
                dateString: recordTime.toLocaleDateString('es-ES')
            };
            
            try {
                // Guardar en Firebase
                const docRef = await db.collection('records').add(record);
                
                // Si es una entrada, establecer como activa
                if (type === 'entry') {
                    state.activeEntry = record;
                    localStorage.setItem(`activeEntry_${state.currentEmployee.id}`, JSON.stringify(record));
                }
                
                // Si es una salida y hay entrada activa, calcular horas
                if (type === 'exit' && state.activeEntry) {
                    const entryTime = new Date(state.activeEntry.timestamp);
                    const exitTime = recordTime;
                    const hoursWorked = (exitTime - entryTime) / (1000 * 60 * 60);
                    
                    // Actualizar registro de salida con horas trabajadas
                    await db.collection('records').doc(docRef.id).update({
                        hoursWorked: hoursWorked.toFixed(2)
                    });
                    
                    // Limpiar entrada activa
                    state.activeEntry = null;
                    localStorage.removeItem(`activeEntry_${state.currentEmployee.id}`);
                }
                
                // Actualizar UI
                updateEmployeeUI();
                
                // Recargar estadísticas
                await loadEmployeeStatistics(state.currentEmployee.id);
                
                // Mostrar mensaje de éxito
                const typeNames = {
                    'entry': 'Entrada',
                    'exit': 'Salida'
                };
                
                showToast(`${typeNames[type]} registrada correctamente`, "success");
                
                // Resetear fecha manual
                if (useManualTime) {
                    elements.manualDatetime.value = formatDateTimeForInput(new Date());
                }
                
            } catch (error) {
                console.error("Error registrando tiempo:", error);
                showToast(`Error: ${error.message}`, "error");
            }
        }

        // Cargar estadísticas del empleado - MODIFICADO para calcular horas por día correctamente
        async function loadEmployeeStatistics(employeeId) {
            try {
                const today = new Date();
                const todayString = today.toISOString().split('T')[0];
                const currentMonth = today.getMonth() + 1;
                const currentYear = today.getFullYear();
                
                // Obtener registros del empleado para el mes actual
                const snapshot = await db.collection('records')
                    .where('employeeId', '==', employeeId)
                    .where('year', '==', currentYear)
                    .where('month', '==', currentMonth)
                    .orderBy('timestamp')
                    .get();
                
                let totalHoursToday = 0;
                let totalHoursMonth = 0;
                let daysWorked = new Set();
                let dailyHours = {}; // Para agrupar horas por día
                
                // Primero, agrupar entradas y salidas por día
                let dailyEntries = {};
                
                snapshot.forEach(doc => {
                    const record = doc.data();
                    
                    // Inicializar el día si no existe
                    if (!dailyEntries[record.date]) {
                        dailyEntries[record.date] = {
                            entries: [],
                            exits: [],
                            travels: []
                        };
                    }
                    
                    // Agrupar por tipo
                    if (record.type === 'entry') {
                        dailyEntries[record.date].entries.push(record);
                    } else if (record.type === 'exit') {
                        dailyEntries[record.date].exits.push(record);
                    } else if (record.type === 'travel') {
                        dailyEntries[record.date].travels.push(record);
                    }
                });
                
                // Calcular horas por día
                Object.keys(dailyEntries).forEach(date => {
                    const dayData = dailyEntries[date];
                    let dayHours = 0;
                    
                    // Calcular horas de viajes (8 horas por viaje)
                    dayHours += dayData.travels.length * 8;
                    
                    // Calcular horas de entradas y salidas
                    // Asumimos que cada entrada tiene su salida correspondiente
                    const entries = dayData.entries.sort((a, b) => 
                        new Date(a.timestamp) - new Date(b.timestamp)
                    );
                    const exits = dayData.exits.sort((a, b) => 
                        new Date(a.timestamp) - new Date(b.timestamp)
                    );
                    
                    // Emparejar entradas con salidas
                    const pairs = Math.min(entries.length, exits.length);
                    for (let i = 0; i < pairs; i++) {
                        const entryTime = new Date(entries[i].timestamp);
                        const exitTime = new Date(exits[i].timestamp);
                        
                        // Asegurar que la salida sea posterior a la entrada
                        if (exitTime > entryTime) {
                            const hoursWorked = (exitTime - entryTime) / (1000 * 60 * 60);
                            dayHours += hoursWorked;
                        }
                    }
                    
                    // Almacenar horas del día
                    dailyHours[date] = dayHours;
                    
                    // Sumar al mes
                    totalHoursMonth += dayHours;
                    
                    // Si hay horas trabajadas, contar como día trabajado
                    if (dayHours > 0 || dayData.travels.length > 0) {
                        daysWorked.add(date);
                    }
                    
                    // Sumar a hoy si corresponde
                    if (date === todayString) {
                        totalHoursToday = dayHours;
                    }
                });
                
                // Actualizar estadísticas
                elements.hoursToday.textContent = formatHours(totalHoursToday);
                elements.hoursMonth.textContent = formatHours(totalHoursMonth);
                elements.daysWorked.textContent = daysWorked.size;
                
            } catch (error) {
                console.error("Error cargando estadísticas:", error);
            }
        }

        // Cargar estadísticas globales para admin - MODIFICADO
        async function loadAdminStatistics() {
            try {
                const today = new Date();
                const todayString = today.toISOString().split('T')[0];
                const currentMonth = today.getMonth() + 1;
                const currentYear = today.getFullYear();
                
                // Obtener todos los registros del mes actual
                const snapshot = await db.collection('records')
                    .where('year', '==', currentYear)
                    .where('month', '==', currentMonth)
                    .orderBy('timestamp')
                    .get();
                
                let totalHoursToday = 0;
                let totalHoursMonth = 0;
                let usedVacationDays = 0;
                let travelDays = 0;
                let travelHours = 0;
                let sickDays = 0;
                let daysWorkedSet = new Set();
                let dailyHoursByEmployee = {};
                
                // Agrupar datos por empleado y día
                snapshot.forEach(doc => {
                    const record = doc.data();
                    const date = record.date;
                    const employeeId = record.employeeId;
                    
                    // Inicializar estructura si no existe
                    if (!dailyHoursByEmployee[employeeId]) {
                        dailyHoursByEmployee[employeeId] = {};
                    }
                    if (!dailyHoursByEmployee[employeeId][date]) {
                        dailyHoursByEmployee[employeeId][date] = {
                            entries: [],
                            exits: [],
                            travels: []
                        };
                    }
                    
                    // Agrupar por tipo
                    if (record.type === 'entry') {
                        dailyHoursByEmployee[employeeId][date].entries.push(record);
                    } else if (record.type === 'exit') {
                        dailyHoursByEmployee[employeeId][date].exits.push(record);
                    } else if (record.type === 'travel') {
                        dailyHoursByEmployee[employeeId][date].travels.push(record);
                    }
                });
                
                // Calcular estadísticas
                Object.keys(dailyHoursByEmployee).forEach(employeeId => {
                    const employeeDays = dailyHoursByEmployee[employeeId];
                    
                    Object.keys(employeeDays).forEach(date => {
                        const dayData = employeeDays[date];
                        let dayHours = 0;
                        
                        // Contar días especiales
                        if (dayData.entries.length > 0 || dayData.exits.length > 0) {
                            daysWorkedSet.add(date + '_' + employeeId);
                        }
                        
                        // Calcular horas de viajes
                        dayData.travels.forEach(() => {
                            travelDays++;
                            travelHours += 8;
                            dayHours += 8;
                        });
                        
                        // Calcular horas de entradas y salidas
                        const entries = dayData.entries.sort((a, b) => 
                            new Date(a.timestamp) - new Date(b.timestamp)
                        );
                        const exits = dayData.exits.sort((a, b) => 
                            new Date(b.timestamp) - new Date(a.timestamp)
                        );
                        
                        // Emparejar entradas con salidas
                        const pairs = Math.min(entries.length, exits.length);
                        for (let i = 0; i < pairs; i++) {
                            const entryTime = new Date(entries[i].timestamp);
                            const exitTime = new Date(exits[i].timestamp);
                            
                            if (exitTime > entryTime) {
                                const hoursWorked = (exitTime - entryTime) / (1000 * 60 * 60);
                                dayHours += hoursWorked;
                            }
                        }
                        
                        // Sumar al mes
                        totalHoursMonth += dayHours;
                        
                        // Sumar a hoy si corresponde
                        if (date === todayString) {
                            totalHoursToday += dayHours;
                        }
                    });
                });
                
                // Contar días especiales
                snapshot.forEach(doc => {
                    const record = doc.data();
                    if (record.type === 'vacation') {
                        usedVacationDays++;
                    } else if (record.type === 'sick') {
                        sickDays++;
                    }
                });
                
                // Actualizar estadísticas
                elements.totalHoursToday.textContent = formatHours(totalHoursToday);
                elements.totalHoursMonth.textContent = formatHours(totalHoursMonth);
                elements.usedVacation.textContent = `${usedVacationDays}d`;
                elements.travelDays.textContent = travelDays;
                elements.travelHours.textContent = formatHours(travelHours);
                elements.sickDays.textContent = sickDays;
                elements.totalDaysWorked.textContent = daysWorkedSet.size;
                
            } catch (error) {
                console.error("Error cargando estadísticas admin:", error);
            }
        }

        // Filtrar registros - MODIFICADO para manejar fechas correctamente
        async function filterRecords() {
            try {
                let query = db.collection('records').orderBy('timestamp', 'desc');
                
                // Aplicar filtros
                const employeeId = elements.filterEmployee.value;
                const year = elements.filterYear.value;
                const month = elements.filterMonth.value;
                const startDate = elements.filterStart.value;
                const endDate = elements.filterEnd.value;
                
                // Construir query dinámica
                if (employeeId) {
                    query = query.where('employeeId', '==', employeeId);
                }
                
                if (year) {
                    query = query.where('year', '==', parseInt(year));
                }
                
                if (month) {
                    query = query.where('month', '==', parseInt(month));
                }
                
                // Obtener todos los registros y filtrar por fecha si es necesario
                const snapshot = await query.get();
                let filteredRecords = [];
                
                snapshot.forEach(doc => {
                    const record = { id: doc.id, ...doc.data() };
                    let include = true;
                    
                    // Filtro por rango de fechas (si se especifica)
                    if (startDate && record.date < startDate) {
                        include = false;
                    }
                    
                    if (endDate && record.date > endDate) {
                        include = false;
                    }
                    
                    // Filtro por tipo
                    const selectedTypes = [];
                    if (elements.filterEntry.checked) selectedTypes.push('entry');
                    if (elements.filterExit.checked) selectedTypes.push('exit');
                    if (elements.filterVacation.checked) selectedTypes.push('vacation');
                    if (elements.filterSick.checked) selectedTypes.push('sick');
                    if (elements.filterTravel.checked) selectedTypes.push('travel');
                    
                    if (selectedTypes.length > 0 && !selectedTypes.includes(record.type)) {
                        include = false;
                    }
                    
                    if (include) {
                        filteredRecords.push(record);
                    }
                });
                
                // Mostrar resultados
                updateAdminRecordsDisplay(filteredRecords);
                
                // Calcular estadísticas filtradas
                calculateFilteredStatistics(filteredRecords);
                
                showToast(`${filteredRecords.length} registros encontrados`, "success");
                
            } catch (error) {
                console.error("Error filtrando registros:", error);
                showToast(`Error: ${error.message}`, "error");
            }
        }

        // Calcular estadísticas filtradas
        function calculateFilteredStatistics(records) {
            let totalHoursToday = 0;
            let totalHoursMonth = 0;
            let usedVacationDays = 0;
            let travelDays = 0;
            let travelHours = 0;
            let sickDays = 0;
            let daysWorkedSet = new Set();
            
            const today = new Date();
            const todayString = today.toISOString().split('T')[0];
            const currentMonth = today.getMonth() + 1;
            const currentYear = today.getFullYear();
            
            // Agrupar por empleado y día
            let dailyData = {};
            
            records.forEach(record => {
                const date = record.date;
                const employeeId = record.employeeId;
                
                // Inicializar estructura
                if (!dailyData[employeeId]) dailyData[employeeId] = {};
                if (!dailyData[employeeId][date]) {
                    dailyData[employeeId][date] = {
                        entries: [],
                        exits: [],
                        travels: []
                    };
                }
                
                // Agrupar por tipo
                if (record.type === 'entry') {
                    dailyData[employeeId][date].entries.push(record);
                } else if (record.type === 'exit') {
                    dailyData[employeeId][date].exits.push(record);
                } else if (record.type === 'travel') {
                    dailyData[employeeId][date].travels.push(record);
                }
            });
            
            // Calcular estadísticas
            Object.keys(dailyData).forEach(employeeId => {
                Object.keys(dailyData[employeeId]).forEach(date => {
                    const dayData = dailyData[employeeId][date];
                    let dayHours = 0;
                    
                    // Contar días trabajados
                    if (dayData.entries.length > 0 || dayData.exits.length > 0) {
                        daysWorkedSet.add(date + '_' + employeeId);
                    }
                    
                    // Horas de viaje
                    dayData.travels.forEach(() => {
                        travelDays++;
                        travelHours += 8;
                        dayHours += 8;
                    });
                    
                    // Calcular horas de entradas/salidas
                    const entries = dayData.entries.sort((a, b) => 
                        new Date(a.timestamp) - new Date(b.timestamp)
                    );
                    const exits = dayData.exits.sort((a, b) => 
                        new Date(b.timestamp) - new Date(a.timestamp)
                    );
                    
                    const pairs = Math.min(entries.length, exits.length);
                    for (let i = 0; i < pairs; i++) {
                        const entryTime = new Date(entries[i].timestamp);
                        const exitTime = new Date(exits[i].timestamp);
                        
                        if (exitTime > entryTime) {
                            const hoursWorked = (exitTime - entryTime) / (1000 * 60 * 60);
                            dayHours += hoursWorked;
                        }
                    }
                    
                    // Sumar al mes si corresponde
                    const recordDate = new Date(date);
                    if (recordDate.getFullYear() === currentYear && 
                        (recordDate.getMonth() + 1) === currentMonth) {
                        totalHoursMonth += dayHours;
                    }
                    
                    // Sumar a hoy si corresponde
                    if (date === todayString) {
                        totalHoursToday += dayHours;
                    }
                });
            });
            
            // Contar días especiales
            records.forEach(record => {
                if (record.type === 'vacation') {
                    usedVacationDays++;
                } else if (record.type === 'sick') {
                    sickDays++;
                }
            });
            
            // Actualizar estadísticas
            elements.totalHoursToday.textContent = formatHours(totalHoursToday);
            elements.totalHoursMonth.textContent = formatHours(totalHoursMonth);
            elements.usedVacation.textContent = `${usedVacationDays}d`;
            elements.travelDays.textContent = travelDays;
            elements.travelHours.textContent = formatHours(travelHours);
            elements.sickDays.textContent = sickDays;
            elements.totalDaysWorked.textContent = daysWorkedSet.size;
        }

        // ... (resto de las funciones se mantienen igual con pequeñas correcciones) ...

        // Actualizar visualización de registros en admin
        function updateAdminRecordsDisplay(records) {
            elements.adminRecords.innerHTML = '';
            
            if (records.length === 0) {
                elements.adminRecords.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-search"></i>
                        <p>No hay registros con los filtros aplicados</p>
                    </div>
                `;
                return;
            }
            
            // Crear tabla para mejor visualización
            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';
            table.innerHTML = `
                <thead>
                    <tr style="background-color: var(--primary); color: white;">
                        <th style="padding: 12px; text-align: left;">Fecha</th>
                        <th style="padding: 12px; text-align: left;">Hora</th>
                        <th style="padding: 12px; text-align: left;">Empleado</th>
                        <th style="padding: 12px; text-align: left;">Tipo</th>
                        <th style="padding: 12px; text-align: left;">Horas</th>
                    </tr>
                </thead>
                <tbody id="records-table-body">
                </tbody>
            `;
            
            elements.adminRecords.appendChild(table);
            const tbody = document.getElementById('records-table-body');
            
            records.forEach(record => {
                const recordTime = new Date(record.timestamp);
                const timeString = recordTime.toLocaleTimeString('es-ES', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                // Usar dateString si existe, o formatear manualmente
                const dateString = record.dateString || recordTime.toLocaleDateString('es-ES');
                
                let typeText = '', typeColor = '';
                switch(record.type) {
                    case 'entry':
                        typeText = 'Entrada';
                        typeColor = 'var(--success)';
                        break;
                    case 'exit':
                        typeText = 'Salida';
                        typeColor = 'var(--danger)';
                        break;
                    case 'vacation':
                        typeText = 'Vacaciones';
                        typeColor = 'var(--vacation)';
                        break;
                    case 'sick':
                        typeText = 'Baja Laboral';
                        typeColor = 'var(--sick)';
                        break;
                    case 'travel':
                        typeText = 'Viaje';
                        typeColor = 'var(--travel)';
                        break;
                }
                
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid #eee';
                row.style.backgroundColor = 'white';
                row.innerHTML = `
                    <td style="padding: 12px;">${dateString}</td>
                    <td style="padding: 12px;">${timeString}</td>
                    <td style="padding: 12px;">${record.employeeName}</td>
                    <td style="padding: 12px;">
                        <span style="color: ${typeColor}; font-weight: 600;">${typeText}</span>
                        ${record.extraVacation ? `<br><small style="color: var(--warning);">+${record.extraVacation} día vacaciones</small>` : ''}
                    </td>
                    <td style="padding: 12px;">
                        ${record.hoursWorked ? `<span style="font-weight: 600;">${parseFloat(record.hoursWorked).toFixed(2)}h</span>` : '-'}
                    </td>
                `;
                
                tbody.appendChild(row);
            });
        }

        // ... (resto del código se mantiene igual) ...

        // Inicializar cuando cargue la página
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>